---
phase: 05-error-handling-polish
plan: 03
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - DictationApp/Sources/App/AppDelegate.swift
  - DictationApp/Sources/Services/TranscriptionManager.swift
autonomous: true

must_haves:
  truths:
    - "Menu bar icon shows processing state during transcription"
    - "Menu bar icon shows error state when transcription fails"
    - "Error state resets to idle after 2 seconds"
    - "Network errors show specific guidance"
  artifacts:
    - path: "DictationApp/Sources/App/AppDelegate.swift"
      provides: "Extended MenuBarIconState with processing and error states"
      contains: "case processing"
  key_links:
    - from: "AppDelegate.swift"
      to: "transcriptionDidComplete/transcriptionDidFail"
      via: "observer updates menu bar icon state"
      pattern: "updateMenuBarIcon.*processing"
    - from: "TranscriptionManager.swift"
      to: "Notification.Name.transcriptionWillStart"
      via: "posts notification before API call"
      pattern: "transcriptionWillStart"
---

<objective>
Add visual feedback through menu bar icon states and network error handling (ERR-04, visual polish)

Purpose: Users need visual feedback about app state. The menu bar icon should clearly indicate when transcription is in progress and briefly show error state when things fail. Network errors need specific guidance.

Output: Extended menu bar states (processing, error) with auto-reset, network error detection
</objective>

<execution_context>
@/Users/justindeisler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/justindeisler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-error-handling-polish/05-RESEARCH.md

# Required context
@DictationApp/Sources/App/AppDelegate.swift (MenuBarIconState enum, updateMenuBarIcon method)
@DictationApp/Sources/Services/TranscriptionManager.swift (handleRecordingCompletion)
@.planning/phases/05-error-handling-polish/05-01-PLAN.md (ErrorNotifier patterns)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend MenuBarIconState with processing and error states</name>
  <files>DictationApp/Sources/App/AppDelegate.swift</files>
  <action>
Modify the MenuBarIconState enum in AppDelegate.swift:

1. Add two new cases to the enum:
```swift
enum MenuBarIconState {
    case idle
    case recording
    case processing    // NEW: Transcribing in progress
    case error         // NEW: Transient error indicator

    var symbolName: String {
        switch self {
        case .idle: return "waveform"
        case .recording: return "waveform.circle.fill"
        case .processing: return "waveform.badge.ellipsis"  // NEW
        case .error: return "waveform.badge.exclamationmark"  // NEW
        }
    }

    var tintColor: NSColor? {
        switch self {
        case .idle: return nil  // Uses template mode
        case .recording: return .systemRed
        case .processing: return .systemBlue  // NEW
        case .error: return .systemYellow      // NEW
        }
    }

    var isTemplate: Bool {
        self == .idle  // Only idle uses template mode
    }
}
```

2. Update `updateMenuBarIcon(state:)` method to handle all states:
```swift
func updateMenuBarIcon(state: MenuBarIconState) {
    guard let button = statusItem?.button else { return }

    let accessibilityDesc: String
    switch state {
    case .idle:
        accessibilityDesc = "Dictation"
    case .recording:
        accessibilityDesc = "Recording"
    case .processing:
        accessibilityDesc = "Transcribing"
    case .error:
        accessibilityDesc = "Error"
    }

    if state == .idle {
        // Template mode for idle (adapts to light/dark)
        let image = NSImage(systemSymbolName: state.symbolName, accessibilityDescription: accessibilityDesc)
        image?.isTemplate = true
        button.image = image
    } else {
        // Explicit color for non-idle states
        let config = NSImage.SymbolConfiguration(paletteColors: [state.tintColor ?? .controlAccentColor])
        if let image = NSImage(systemSymbolName: state.symbolName, accessibilityDescription: accessibilityDesc)?
            .withSymbolConfiguration(config) {
            image.isTemplate = false
            button.image = image
        }
    }

    // Auto-reset error state to idle after 2 seconds
    if state == .error {
        Task { @MainActor in
            try? await Task.sleep(nanoseconds: 2_000_000_000)
            // Only reset if still showing error (user might have started new recording)
            if button.image?.accessibilityDescription == "Error" {
                updateMenuBarIcon(state: .idle)
            }
        }
    }
}
```

Key changes:
- processing state uses blue color and ellipsis badge
- error state uses yellow color and exclamation badge
- error state auto-resets to idle after 2 seconds
  </action>
  <verify>Project builds and grep confirms "case processing" and "case error" exist in MenuBarIconState enum</verify>
  <done>MenuBarIconState has processing and error cases with appropriate symbols and colors</done>
</task>

<task type="auto">
  <name>Task 2: Add transcription lifecycle notifications and observers</name>
  <files>
    DictationApp/Sources/Services/TranscriptionManager.swift
    DictationApp/Sources/App/AppDelegate.swift
  </files>
  <action>
**In TranscriptionManager.swift:**

1. Add a new notification name at the top (in the Notification.Name extension):
```swift
static let transcriptionWillStart = Notification.Name("transcriptionWillStart")
```

2. In `handleRecordingCompletion(audioURL:)`, post transcriptionWillStart notification BEFORE the API call:
```swift
func handleRecordingCompletion(audioURL: URL) async -> String? {
    let languagePreference = UserDefaults.standard.string(forKey: "transcriptionLanguage") ?? "auto"
    let language: String? = languagePreference == "auto" ? nil : languagePreference

    // Post notification that transcription is starting (for menu bar icon)
    NotificationCenter.default.post(
        name: .transcriptionWillStart,
        object: nil
    )

    do {
        // ... existing transcription code
    }
}
```

**In AppDelegate.swift:**

1. Add observer in `setupTranscriptionObservers()`:
```swift
NotificationCenter.default.addObserver(
    self,
    selector: #selector(handleTranscriptionWillStart),
    name: .transcriptionWillStart,
    object: nil
)
```

2. Add handler method:
```swift
@objc func handleTranscriptionWillStart() {
    updateMenuBarIcon(state: .processing)
}
```

3. Modify `handleRecordingStopped` to NOT reset to idle immediately (let transcription lifecycle handle it):
```swift
@objc func handleRecordingStopped(_ notification: Notification) {
    // Don't reset to idle here - let transcription lifecycle handle icon state
    // Recording stopped means we're transitioning to processing state
    // The transcriptionWillStart notification will set processing
    // The transcriptionDidComplete/transcriptionDidFail will reset to idle/error
}
```

4. In existing `handleTranscriptionComplete`, ensure icon resets to idle:
```swift
@objc func handleTranscriptionComplete(_ notification: Notification) {
    // Reset icon to idle on successful transcription
    updateMenuBarIcon(state: .idle)

    guard let text = notification.object as? String else {
        print("Transcription notification missing text")
        return
    }

    Task {
        await PasteManager.shared.pasteText(text)
    }
}
```

5. In `handleTranscriptionFailed` (from 05-01), set error state before showing notification:
```swift
@objc func handleTranscriptionFailed(_ notification: Notification) {
    // Show error state in menu bar (transient, auto-resets)
    updateMenuBarIcon(state: .error)

    // ... existing error notification code from 05-01
}
```

State machine flow:
idle -> (hotkey) -> recording -> (hotkey) -> processing -> (API complete) -> idle
                                          -> (API error) -> error -> (2s) -> idle
  </action>
  <verify>Project builds, grep confirms transcriptionWillStart notification exists, grep confirms handleTranscriptionWillStart observer exists</verify>
  <done>Menu bar icon shows processing during transcription and error state on failure</done>
</task>

<task type="auto">
  <name>Task 3: Enhance TranscriptionManager with network error context</name>
  <files>DictationApp/Sources/Services/TranscriptionManager.swift</files>
  <action>
Update TranscriptionManager.swift to preserve full error context in the transcriptionDidFail notification:

Change the error posting to use userInfo dictionary instead of just object:

```swift
} catch let error as APIError {
    print("Transcription failed: \(error.userMessage)")

    // Post error with full context for ErrorNotifier (ERR-01, ERR-02)
    NotificationCenter.default.post(
        name: .transcriptionDidFail,
        object: nil,
        userInfo: ["error": error]
    )
    return nil
} catch let error as URLError {
    // Handle URLError specifically for better network error messages (ERR-04)
    print("Network error during transcription: \(error.localizedDescription)")

    let apiError: APIError
    switch error.code {
    case .notConnectedToInternet, .networkConnectionLost:
        apiError = .networkError(error)
    case .timedOut:
        apiError = .timeout
    default:
        apiError = .networkError(error)
    }

    NotificationCenter.default.post(
        name: .transcriptionDidFail,
        object: nil,
        userInfo: ["error": apiError]
    )
    return nil
} catch {
    print("Transcription failed: \(error.localizedDescription)")

    NotificationCenter.default.post(
        name: .transcriptionDidFail,
        object: nil,
        userInfo: ["error": error]
    )
    return nil
}
```

This ensures:
1. APIError is passed with full context
2. URLError is converted to appropriate APIError for consistent handling
3. Other errors are passed through for ErrorNotifier to handle

Note: The catch block order matters - URLError before generic Error to catch network errors specifically.
  </action>
  <verify>Project builds, grep confirms userInfo containing error is posted in transcriptionDidFail</verify>
  <done>TranscriptionManager posts errors with full context including network error differentiation</done>
</task>

</tasks>

<verification>
1. Build succeeds: `xcodebuild -project DictationApp/DictationApp.xcodeproj -scheme DictationApp build`
2. MenuBarIconState has four cases: idle, recording, processing, error
3. transcriptionWillStart notification exists and is posted before API call
4. AppDelegate observes transcriptionWillStart and sets processing state
5. Error state auto-resets to idle after 2 seconds
6. TranscriptionManager posts errors with userInfo dictionary
</verification>

<success_criteria>
1. Menu bar icon turns blue during transcription (processing state)
2. Menu bar icon briefly shows yellow when transcription fails (error state)
3. Error state automatically returns to idle after 2 seconds
4. Network errors are properly categorized (timeout vs. no connection)
5. State machine: idle -> recording -> processing -> idle/error -> idle
</success_criteria>

<output>
After completion, create `.planning/phases/05-error-handling-polish/05-03-SUMMARY.md`
</output>
