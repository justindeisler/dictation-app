---
phase: 05-error-handling-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - DictationApp/Sources/Services/ErrorNotifier.swift
  - DictationApp/Sources/Services/NotificationThrottler.swift
  - DictationApp/Sources/App/AppDelegate.swift
autonomous: true

must_haves:
  truths:
    - "User sees notification when transcription fails"
    - "Notification explains specific failure reason"
    - "Same error does not spam multiple notifications"
  artifacts:
    - path: "DictationApp/Sources/Services/ErrorNotifier.swift"
      provides: "Centralized error presentation with notification categories"
      exports: ["ErrorNotifier"]
    - path: "DictationApp/Sources/Services/NotificationThrottler.swift"
      provides: "Time-based notification spam prevention"
      exports: ["NotificationThrottler"]
  key_links:
    - from: "AppDelegate.swift"
      to: "ErrorNotifier.swift"
      via: "transcriptionDidFail observer calls ErrorNotifier"
      pattern: "ErrorNotifier\\.shared\\.showError"
    - from: "ErrorNotifier.swift"
      to: "NotificationThrottler.swift"
      via: "throttler check before showing notification"
      pattern: "throttler\\.shouldShowNotification"
---

<objective>
Implement error notification system with spam prevention for transcription failures (ERR-01, ERR-02)

Purpose: Users need clear feedback when transcription fails, with specific explanations (network error, timeout, API key invalid, rate limit). Notifications must not spam users with repeated errors.

Output: ErrorNotifier service, NotificationThrottler service, and AppDelegate integration
</objective>

<execution_context>
@/Users/justindeisler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/justindeisler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-error-handling-polish/05-RESEARCH.md

# Current error infrastructure
@DictationApp/Sources/Services/APIClient.swift (APIError enum with userMessage)
@DictationApp/Sources/Services/TranscriptionManager.swift (posts transcriptionDidFail)
@DictationApp/Sources/App/AppDelegate.swift (UNUserNotificationCenter delegate)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create NotificationThrottler service</name>
  <files>DictationApp/Sources/Services/NotificationThrottler.swift</files>
  <action>
Create NotificationThrottler.swift with:

1. @MainActor singleton pattern (matching project conventions)
2. Private dictionary `lastNotificationTimes: [String: Date]` for tracking
3. Constant `minimumInterval: TimeInterval = 5.0` (5 seconds between same category)
4. `shouldShowNotification(category: String) -> Bool` method:
   - Check if category has been shown within minimumInterval
   - If yes, log suppression and return false
   - If no, update lastNotificationTimes and return true
5. `reset(category: String)` method for testing/clearing specific categories

Pattern from research:
```swift
@MainActor
final class NotificationThrottler {
    static let shared = NotificationThrottler()

    private var lastNotificationTimes: [String: Date] = [:]
    private let minimumInterval: TimeInterval = 5.0

    private init() {}

    func shouldShowNotification(category: String) -> Bool {
        let now = Date()

        if let lastTime = lastNotificationTimes[category] {
            let elapsed = now.timeIntervalSince(lastTime)
            if elapsed < minimumInterval {
                print("Suppressing duplicate notification for \(category)")
                return false
            }
        }

        lastNotificationTimes[category] = now
        return true
    }

    func reset(category: String) {
        lastNotificationTimes.removeValue(forKey: category)
    }
}
```
  </action>
  <verify>File exists at DictationApp/Sources/Services/NotificationThrottler.swift and project builds with `xcodebuild -project DictationApp/DictationApp.xcodeproj -scheme DictationApp build`</verify>
  <done>NotificationThrottler service exists with shouldShowNotification and reset methods</done>
</task>

<task type="auto">
  <name>Task 2: Create ErrorNotifier service with notification categories</name>
  <files>DictationApp/Sources/Services/ErrorNotifier.swift</files>
  <action>
Create ErrorNotifier.swift with:

1. @MainActor singleton pattern
2. Dependency on NotificationThrottler
3. Notification category constants:
   - `ERROR_NETWORK` for network/timeout errors
   - `ERROR_API_KEY` for invalid/missing API key
   - `ERROR_RATE_LIMIT` for rate limiting
   - `ERROR_GENERAL` for other errors
4. `showTranscriptionError(_ error: Error)` method that:
   - Determines error category from error type
   - Checks throttler before showing notification
   - Creates UNMutableNotificationContent with appropriate title/body
   - Uses UNUserNotificationCenter to show notification
5. `setupNotificationCategories()` method to register categories with UNUserNotificationCenter

Error category mapping (from APIError):
- `.invalidAPIKey` -> "ERROR_API_KEY", title: "API Key Invalid"
- `.networkError`, `.timeout` -> "ERROR_NETWORK", title: "Network Error" or "Request Timed Out"
- `.rateLimitExceeded` -> "ERROR_RATE_LIMIT", title: "Rate Limit Exceeded"
- `.fileTooLarge` -> "ERROR_GENERAL", title: "Audio File Too Large"
- `.serverError`, `.invalidResponse` -> "ERROR_GENERAL", title: "Transcription Failed"
- Other errors -> "ERROR_GENERAL", title: "Error"

Use error.userMessage (from APIError.userMessage or Error extension) for notification body.

Pattern:
```swift
func showTranscriptionError(_ error: Error) async {
    // Determine category
    let category: String
    let title: String

    if let apiError = error as? APIError {
        switch apiError {
        case .invalidAPIKey:
            category = "ERROR_API_KEY"
            title = "API Key Invalid"
        case .networkError, .timeout:
            category = "ERROR_NETWORK"
            title = apiError == .timeout ? "Request Timed Out" : "Network Error"
        case .rateLimitExceeded:
            category = "ERROR_RATE_LIMIT"
            title = "Rate Limit Exceeded"
        default:
            category = "ERROR_GENERAL"
            title = "Transcription Failed"
        }
    } else {
        category = "ERROR_GENERAL"
        title = "Error"
    }

    // Check throttler
    guard NotificationThrottler.shared.shouldShowNotification(category: category) else {
        return
    }

    // Show notification
    let content = UNMutableNotificationContent()
    content.title = title
    content.body = (error as? APIError)?.userMessage ?? error.localizedDescription
    content.sound = .default
    content.categoryIdentifier = category

    let request = UNNotificationRequest(
        identifier: UUID().uuidString,
        content: content,
        trigger: nil
    )

    try? await UNUserNotificationCenter.current().add(request)
}
```

Include import for UserNotifications.
  </action>
  <verify>File exists at DictationApp/Sources/Services/ErrorNotifier.swift and project builds</verify>
  <done>ErrorNotifier service exists with showTranscriptionError method and notification categories</done>
</task>

<task type="auto">
  <name>Task 3: Wire ErrorNotifier to transcriptionDidFail in AppDelegate</name>
  <files>DictationApp/Sources/App/AppDelegate.swift</files>
  <action>
Modify AppDelegate.swift to:

1. Add observer for `.transcriptionDidFail` in `setupTranscriptionObservers()`:
```swift
NotificationCenter.default.addObserver(
    self,
    selector: #selector(handleTranscriptionFailed),
    name: .transcriptionDidFail,
    object: nil
)
```

2. Add handler method `handleTranscriptionFailed`:
```swift
@objc func handleTranscriptionFailed(_ notification: Notification) {
    // Get error from userInfo (TranscriptionManager posts error there)
    // If not in userInfo, treat the object as the error message string
    let error: Error

    if let apiError = notification.userInfo?["error"] as? Error {
        error = apiError
    } else if let errorMessage = notification.object as? String {
        // Legacy support: TranscriptionManager posts error.userMessage as object
        error = NSError(domain: "TranscriptionError", code: -1,
                       userInfo: [NSLocalizedDescriptionKey: errorMessage])
    } else {
        error = NSError(domain: "TranscriptionError", code: -1,
                       userInfo: [NSLocalizedDescriptionKey: "Unknown error"])
    }

    Task {
        await ErrorNotifier.shared.showTranscriptionError(error)
    }
}
```

3. Call ErrorNotifier.shared.setupNotificationCategories() in setupNotifications() method to register error categories alongside existing TRANSCRIPTION_READY category.

Note: TranscriptionManager currently posts error.userMessage as object. The handler should handle both formats (Error object in userInfo vs string as object) for compatibility.
  </action>
  <verify>Build project and verify: 1) No compile errors, 2) grep confirms handleTranscriptionFailed exists, 3) grep confirms ErrorNotifier.shared usage</verify>
  <done>AppDelegate observes transcriptionDidFail and routes errors to ErrorNotifier</done>
</task>

</tasks>

<verification>
1. Build succeeds: `xcodebuild -project DictationApp/DictationApp.xcodeproj -scheme DictationApp build`
2. ErrorNotifier.swift exists with showTranscriptionError method
3. NotificationThrottler.swift exists with shouldShowNotification method
4. AppDelegate has handleTranscriptionFailed observer wired to ErrorNotifier
5. Notification categories registered for error types
</verification>

<success_criteria>
1. When transcription fails, user sees notification with clear title and explanation
2. Notification content matches error type (network, API key, timeout, etc.)
3. Repeated errors within 5 seconds do not spam multiple notifications
4. Project builds without errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-error-handling-polish/05-01-SUMMARY.md`
</output>
